## The big task that a *basic* bootstrap script has to do is:
##
## * Startup
## * Look for a local library and set it on the path, if it's there
## * Load context
##
## This is going to try and do this in a fairly simple-minded way that
## will meet my needs for things like queuer/rrq/didewin.
##
## The things that are controlled by arguments are
##
## * context root
## * task id
##
## The things that are controlled by environment variable
##
## * start parallel cluster
## * propagate error
## * install (perhaps)
##
## There is going to be a bunch of this code that is just to support
## the installation of the script, and other bits that are involved in
## running things.  Hopefully it will all work itself out...
##
## Other scripts that will be useful might include a package
## installation script.
write_scripts <- function(path) {
  path_bin <- path_bin(path)
  dir.create(path_bin, FALSE, TRUE)
  write_script_task_run(path_bin)
}

write_script <- function(text, dest) {
  writeLines(text, dest)
  Sys.chmod(dest, "0755")
}

write_script_task_run <- function(path_bin) {
  code <- c("#!/usr/bin/env Rscript",
            "# Autogenerated by context; do not edit",
            "library(methods)",
            ## "message('args:')",
            ## "message(paste(commandArgs(), collapse = ', '))",
            "local({",
            collect_bootstrap_functions("bootstrap_context"),
            "bootstrap_context(name = 'task_run', n = 1L)",
            "})",
            "context:::main_task_run()")
  write_script(code, file.path(path_bin, "task_run"))
}

bootstrap_context <- function(args = commandArgs(TRUE),
                              name = "context", n = 0L) {
  args <- parse_command_args(args, name, n)
  use_local_library(path_library(args$root), FALSE)
  if (!requireNamespace("context", quietly = TRUE)) {
    stop("Could not find context package; aborting startup")
  }
  invisible(args$args)
}

use_local_library <- function(lib, create = FALSE) {
  if (create && !file.exists(lib)) {
    dir.create(lib, FALSE, TRUE)
  }
  if (file.exists(lib)) {
    ## TODO: if we're dealing with adding existing lib paths here then
    ## they need to be joined with ':' on unix and ';' on Windows -
    ## see .Platform$path.sep
    .libPaths(union(lib, .libPaths()))
    Sys.setenv("R_LIBS_USER" = lib)
    context_log("lib", lib)
  }
}

parse_command_args <- function(args, name, n) {
  nargs <- length(args)
  req <- n + 1L
  if (nargs < req[[1L]]) {
    stop(sprintf(
      "At least %d %s required\nUsage: %s <root> ...",
      req[[1L]], ngettext(req[[1L]], "argument", "arguments"), name))
  }
  if (length(n) == 2L && nargs > req[[2L]]) {
    stop(sprintf(
      "At most %d arguments allowed\nUsage: %s <root> ...", req[[2]], name))
  }
  list(n = nargs - 1L,
       root = args[[1L]],
       args = args[-1L])
}

main_task_run <- function(args = commandArgs(TRUE)) {
  context_log_start()
  context_log("init", Sys_time())
  context_log("hostname", hostname())
  context_log("process", process_id())
  context_log("version", packageVersion("context"))
  args <- parse_command_args(args, "task_run", c(1L, 1L))

  root <- context_root_get(args$root)
  task_id <- args$args[[1L]]

  cores <- Sys.getenv("CONTEXT_CORES")
  if (nzchar(cores) && is.null(par$cl)) {
    cores <- as.integer(cores)
    context_log("parallel",
                sprintf("running as parallel job [%d cores]", cores))
    context_id <- task_context(task_id, root)
    start_parallel_cluster(cores, context_read(context_id, root))
    on.exit(stop_parallel_cluster())
  } else {
    context_log("parallel", "running as single core job")
  }

  res <- task_run(task_id, root, envir = .GlobalEnv)

  propagate_error <- toupper(Sys.getenv("CONTEXT_PROPAGATE_ERROR")) == "TRUE"

  if (propagate_error && inherits(res, "context_task_error")) {
    stop("Error while running task:\n", attr(res, "condition")$message)
  }

  invisible()
}

collect_bootstrap_functions <- function(name, env = NULL) {
  assert_scalar_character(name)
  env <- env %||% environment(collect_bootstrap_functions)
  vcapply(c(name, find_functions(env[[name]], env)), fun_to_str, env,
          USE.NAMES = FALSE)
}
