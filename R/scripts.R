##' Write a very simple context script.  This can be used for
##' applications that need to use context, including setting up the
##' library the context is itself found in.  No fancy argument
##' matching will be done (e.g., optparse, docopt).
##'
##' @title Write context-using script
##' @param path Path to the root of the context
##' @param name Name of the script; this will be the filename
##' @param target The name function to call.  This must be at least
##'   namespace qualified ("::") but probably will be a hidden
##'   function (":::")
##' @param nargs The number of arguments, in addition to the context
##'   root, that the script takes.  This can be a vector of length two
##'   where minimum and maximum numbers of arguments are supported.
##' @export
write_context_script <- function(path, name, target, nargs) {
  full <- file.path(path_bin(path), name)
  if (file.exists(full)) {
    return(full)
  }
  if (length(nargs) == 1L) {
    s_nargs <- sprintf("%dL", nargs)
  } else if (length(nargs) == 2L) {
    s_nargs <- sprintf("%d:%d", nargs[[1]], nargs[[2]])
  } else {
    stop("Invalid input for 'nargs'")
  }

  ## http://r.789695.n4.nabble.com/Error-message-Rscript-should-not-be-used-without-a-path-td4748071.html
  ##
  ## This is actually pretty hard to get right because we, in tests we
  ## want the same R but if we're doing this for running with the
  ## cluster we don't want to do that!  Let's just se what this breaks
  ## for now.
  Rscript <- file.path(R.home("bin"), "Rscript")
  code <- c(sprintf("#!%s", Rscript),
            "# Autogenerated by context; do not edit",
            "library(methods)",
            ## "message('args:')",
            ## "message(paste(commandArgs(TRUE), collapse = ', '))",
            "local({",
            "context_cache <- NULL",
            collect_bootstrap_functions("bootstrap_context"),
            sprintf("bootstrap_context(name = '%s', n = %s)", name, s_nargs),
            "})",
            sprintf("%s()", target))

  write_script(path, name, code)
}

##' @param args Arguments passed to the script, as returned by
##'   \code{commandArgs(TRUE)}.  Will be a character vector
##' @export
##' @rdname write_context_script
parse_context_args <- function(args, name, nargs) {
  rec <- length(args)
  req <- nargs + 1L
  if (rec < req[[1L]]) {
    stop(sprintf(
      "At least %d %s required (given %d)\nUsage: %s <root> ...",
      req[[1L]], ngettext(req[[1L]], "argument", "arguments"), rec, name),
      call. = FALSE)
  }
  if (length(nargs) == 2L && rec > req[[2L]]) {
    stop(sprintf(
      "At most %d arguments allowed (given %d)\nUsage: %s <root> ...",
      req[[2]], rec, name), call. = FALSE)
  }
  list(n = rec - 1L,
       root = args[[1L]],
       args = args[-1L])
}

## internals

## The big task that a *basic* bootstrap script has to do is:
##
## * Startup
## * Look for a local library and set it on the path, if it's there
## * Load context
##
## This is going to try and do this in a fairly simple-minded way that
## will meet my needs for things like queuer/rrq/didewin.
##
## The things that are controlled by arguments are
##
## * context root
## * task id
##
## The things that are controlled by environment variable
##
## * start parallel cluster
## * propagate error
## * install (perhaps)
##
## There is going to be a bunch of this code that is just to support
## the installation of the script, and other bits that are involved in
## running things.  Hopefully it will all work itself out...
##
## Other scripts that will be useful might include a package
## installation script.
write_scripts <- function(path) {
  write_script_task_run(path)
  write_script_bootstrap(path)
}

write_script <- function(path, name, text) {
  dir.create(path_bin(path), FALSE, TRUE)
  dest <- file.path(path_bin(path), name)
  writeLines(text, dest)
  Sys.chmod(dest, "0755")
  dest
}

write_script_task_run <- function(path) {
  write_context_script(path, "task_run", "context:::main_task_run", 1L)
}

write_script_bootstrap <- function(path) {
  code <- c("#!/usr/bin/env Rscript",
            "# Autogenerated by context; do not edit",
            "library(methods)",
            "local({",
            "context_cache <- NULL",
            collect_bootstrap_functions("bootstrap_context"),
            "bootstrap_context(name = 'context_bootstrap', n = 1L)",
            "})")
  write_script(path, "bootstrap", code)
}

bootstrap_context <- function(args = commandArgs(TRUE),
                              name = "context", n = 0L) {
  args <- parse_context_args(args, name, n)
  context_log("hello", Sys_time())
  context_log("wd", getwd())
  if (nzchar(Sys.getenv("CONTEXT_BOOTSTRAP"))) {
    context_log("bootstrap", "")
    use_local_library(path_library(args$root))
  }

  if (!requireNamespace("context", quietly = TRUE)) {
    stop("Could not find context package; aborting startup")
  }
  invisible(args$args)
}


main_task_run <- function(args = commandArgs(TRUE)) {
  context_log("init", Sys_time())
  context_log("hostname", hostname())
  context_log("process", process_id())
  context_log("version", packageVersion("context"))

  ## There is no way of doing any error handling if we have not yet
  ## got the database loaded because we don't even know where things
  ## are being stored.  So the first step is to get the database
  ## loaded.
  ##
  ## Of course, this means that just parsing arguments (which can
  ## throw errors) can leave jobs stranded in PENDING.
  args <- parse_context_args(args, "task_run", c(1L, 1L))
  root <- context_root_get(args$root)
  db <- root$db
  task_id <- args$args[[1L]]

  ## This section here runs the load so that if things go pear shaped
  ## then we'll at least capture the error and set the task status
  ## appropriately to ERROR.  Unlikel running the task itself, this
  ## *always* propagates the error (so Rscript exits with status != 0)
  ## because this can never be considered an uncontrolled error.
  warnings <- collector()
  handler <- function(e) {
    db$set(task_id, TASK_ERROR, "task_status")
    trace <- call_trace(0, 3)
    e$warnings <- warnings$get()
    e$trace <- trace
    class(e) <- c("context_task_error", class(e))
    db$set(task_id, e, "task_results")
  }
  withCallingHandlers(
    error = handler,
    warning = function(e) warnings$add(e),
    {
      context_id <- task_context(task_id, root)
      if (is.na(context_id)) {
        ## I don't think that this can be triggered, but it seems like
        ## if a bug in the package *makes* it triggerable, this will
        ## be a decent message
        stop("[context bug] No context found for task ", task_id) # nocov
      }
      ctx <- context_load(context_read(context_id, root, root$db),
                          .GlobalEnv)

      cores <- Sys.getenv("CONTEXT_CORES")
      if (nzchar(cores) && is.null(context_cache$cl)) {
        cores <- as.integer(cores)
        context_log("parallel",
                    sprintf("running as parallel job [%d cores]", cores))
        parallel_cluster_start(cores, context_read(context_id, root))
        on.exit(parallel_cluster_stop())
      } else {
        context_log("parallel", "running as single core job")
      }
    })

  ## Below here, error handling is done within task_run
  res <- task_run(task_id, ctx)

  propagate_error <- toupper(Sys.getenv("CONTEXT_PROPAGATE_ERROR")) == "TRUE"
  if (propagate_error && inherits(res, "context_task_error")) {
    stop("Error while running task:\n", attr(res, "condition")$message)
  }

  invisible()
}

collect_bootstrap_functions <- function(name, env = NULL) {
  assert_scalar_character(name)
  env <- env %||% environment(collect_bootstrap_functions)
  vcapply(c(name, find_functions(env[[name]], env)), fun_to_str, env,
          USE.NAMES = FALSE)
}
