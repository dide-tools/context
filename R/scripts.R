## The big task that a *basic* bootstrap script has to do is:
##
## * Startup
## * Look for a local library and set it on the path, if it's there
## * Load context
##
## This is going to try and do this in a fairly simple-minded way that
## will meet my needs for things like queuer/rrq/didewin.
##
## The things that are controlled by arguments are
##
## * context root
## * task id
##
## The things that are controlled by environment variable
##
## * start parallel cluster
## * propagate error
## * install (perhaps)
##
## There is going to be a bunch of this code that is just to support
## the installation of the script, and other bits that are involved in
## running things.  Hopefully it will all work itself out...
##
## Other scripts that will be useful might include a package
## installation script.
write_scripts <- function(path) {
  write_script_task_run(path)
  write_script_bootstrap(path)
}

write_script <- function(path, name, text) {
  dir.create(path_bin(path), FALSE, TRUE)
  dest <- file.path(path_bin(path), name)
  writeLines(text, dest)
  Sys.chmod(dest, "0755")
}

write_script_task_run <- function(path) {
  write_context_script(path, "task_run", "context:::main_task_run", 1L)
}

write_script_bootstrap <- function(path) {
  code <- c("#!/usr/bin/env Rscript",
            "# Autogenerated by context; do not edit",
            "library(methods)",
            "local({",
            "context_cache <- NULL",
            collect_bootstrap_functions("bootstrap_context"),
            "bootstrap_context(name = 'context_bootstrap', n = 1L)",
            "})")
  write_script(path, "bootstrap", code)
}

write_context_script <- function(path, name, target, args) {
  if (file.exists(file.path(path_bin(path), name))) {
    return()
  }
  if (length(args) == 1L) {
    s_args <- sprintf("%dL", args)
  } else if (length(args) == 2L) {
    s_args <- sprintf("%d:%d", args[[1]], args[[2]])
  } else {
    stop("Invalid input for 'args'")
  }

  code <- c("#!/usr/bin/env Rscript",
            "# Autogenerated by context; do not edit",
            "library(methods)",
            ## "message('args:')",
            ## "message(paste(commandArgs(TRUE), collapse = ', '))",
            "local({",
            "context_cache <- NULL",
            collect_bootstrap_functions("bootstrap_context"),
            sprintf("bootstrap_context(name = '%s', n = %s)", name, s_args),
            "})",
            sprintf("%s()", target))

  write_script(path, name, code)
}

bootstrap_context <- function(args = commandArgs(TRUE),
                              name = "context", n = 0L) {
  if (!nzchar(Sys.getenv("CONTEXT_QUIET"))) {
    options(context.log = TRUE)
  }
  args <- parse_command_args(args, name, n)
  context_log("bootstrap", Sys_time())
  context_log("wd", getwd())
  use_local_library(path_library(args$root), FALSE)
  if (!requireNamespace("context", quietly = TRUE)) {
    stop("Could not find context package; aborting startup")
  }
  invisible(args$args)
}

use_local_library <- function(lib, create = FALSE) {
  if (create && !file.exists(lib)) {
    dir.create(lib, FALSE, TRUE)
  }
  if (file.exists(lib)) {
    ## TODO: if we're dealing with adding existing lib paths here then
    ## they need to be joined with ':' on unix and ';' on Windows -
    ## see .Platform$path.sep
    .libPaths(union(lib, .libPaths()))
    Sys.setenv("R_LIBS_USER" = lib)
    context_log("lib", lib)
  } else {
    context_log("WARNING", sprintf("*** library not found at %s ***", lib))
  }
}

## TODO: optionally allow a vector of names here for nicer debugging
parse_command_args <- function(args, name, n) {
  nargs <- length(args)
  req <- n + 1L
  if (nargs < req[[1L]]) {
    stop(sprintf(
      "At least %d %s required (given %d)\nUsage: %s <root> ...",
      req[[1L]], ngettext(req[[1L]], "argument", "arguments"), nargs, name),
      call. = FALSE)
  }
  if (length(n) == 2L && nargs > req[[2L]]) {
    stop(sprintf(
      "At most %d arguments allowed (given %d)\nUsage: %s <root> ...",
      req[[2]], nargs, name), call. = FALSE)
  }
  list(n = nargs - 1L,
       root = args[[1L]],
       args = args[-1L])
}

main_task_run <- function(args = commandArgs(TRUE)) {
  context_log_start()
  context_log("init", Sys_time())
  context_log("hostname", hostname())
  context_log("process", process_id())
  context_log("version", packageVersion("context"))
  args <- parse_command_args(args, "task_run", c(1L, 1L))

  root <- context_root_get(args$root)
  task_id <- args$args[[1L]]

  context_id <- task_context(task_id, root)
  if (is.na(context_id)) {
    stop("No context found for task ", context_id)
  }
  ctx <- context_load(context_read(context_id, root, root$db),
                      .GlobalEnv)

  cores <- Sys.getenv("CONTEXT_CORES")
  if (nzchar(cores) && is.null(context_cache$cl)) {
    cores <- as.integer(cores)
    context_log("parallel",
                sprintf("running as parallel job [%d cores]", cores))
    parallel_cluster_start(cores, context_read(context_id, root))
    on.exit(parallel_cluster_stop())
  } else {
    context_log("parallel", "running as single core job")
  }

  res <- task_run(task_id, ctx)

  propagate_error <- toupper(Sys.getenv("CONTEXT_PROPAGATE_ERROR")) == "TRUE"

  if (propagate_error && inherits(res, "context_task_error")) {
    stop("Error while running task:\n", attr(res, "condition")$message)
  }

  invisible()
}

collect_bootstrap_functions <- function(name, env = NULL) {
  assert_scalar_character(name)
  env <- env %||% environment(collect_bootstrap_functions)
  vcapply(c(name, find_functions(env[[name]], env)), fun_to_str, env,
          USE.NAMES = FALSE)
}
